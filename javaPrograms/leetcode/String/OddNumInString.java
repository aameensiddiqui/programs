/*
static {
    for(int i = 0; i < 500; ++i){
        largestOddNumber("1");
    }
}
Runs once when the class is loaded into memory - before main() or
any method is called.

In this code, it calls largestOddNumber("1") 500 times before the program
even starts processing real test cases.

Why someone might put this here
This is actually a JIT warm-up trick:

Java's JIT compiler (Just-In-Time compiler) optimizes code at runtime.

The first few calls to a method run in interpreted mode (slower).

After enough calls, the JIT compiles the method into optimized native machine code.

By calling largestOddNumber("1") 500 times in the static block, the JIT optimizer
gets triggered before the actual test input is processed - so when the real input
comes, it's already running compiled, optimized code.

Why it's faster
Without the warm-up, the first real test case is processed in interpreted mode (slow).

With the warm-up, the method is already "hot" and compiled, so the first real test
case benefits from maximum speed.

This effect is more noticeable in competitive programming environments where:

Execution time limits are strict.

Only a few large test cases run, so warming up before them matters.

Note
This doesn't change algorithmic speed (O(n) is still O(n)), it just removes the
initial JIT "cold start" cost.

In real-world production code, this pattern is almost never needed -
it's mostly for micro-benchmarks or competitive programming where every millisecond counts.
*/
class OddNumInString {
    static {
        for(int i = 0; i < 500; ++i) largestOddNumber("1");
    }
    public static String largestOddNumber(String s) {
        for(int i = s.length()-1; i >= 0; --i) {
            if((s.charAt(i)-'0') % 2 != 0) return s.substring(0, i+1);
        }
        return "";
    }
 
    public static void main(String[]args) {
        String s = "604793036149872839992192124938430894870605664187758030468750635190361332541107609543173505831997179110065120704961108046619639907676991507859311091939284567972320024968549822749545089203880653331537795995946521707303379337563620501508124739500334234258323024102615347355289611223386559630993842530428973179128685787255877749690333736346692548121478539078956776657546027341514888143111508353544439284044566907826333738987751536637780529240755366684590902259999663618637159741218209702316433481705802566212867163234672994938743027169385977790147546926329676291603248413768151185672438070176563600412577711837274220912418621042752308370816470900633533106005313122068155839386613315520650637314950136497189241956252571509976838903091436391025743263039752450864035533803396852701713023212983381674233629344973471566277689627066149828246747468971527323008576665674916016923645875066337050249724399201166918362644886946119524364027011686462252237281793230234679121416141509377100409013806984775965555356690551076209184357978630505057397691567164932898027148727178333211602564347128715399156686334141115931952569040983665528993160875243772942095481497374605233027642086567566184438612590472927742333059126620157201859626301367492617647501111783099974192676492151826068887189813129208751029321840118458260340848729758598831030324329839542961844626714628314359892625660931418186151554234016361128497185948491025625889679240822269405396727578446834146511131290148706827788160930685389097283215285067625153814474430963480797050975451052650167318826170243765456284177225605313402665023741678725686211022580305690674471639282341436371892392312604326093106684335670860414545635020005347491624755411082555989534396112910933711895473820236848557161768802942409036788127868669432029390878844344812308340242403381059551842694500534240891649837354396273652717272239724042269312163761820916601002314290018513279724572308481001841862030366254361721314519515109226859262494514754102252677119642152265576769523668788788361968931350305872105524728633302126065019179202521310962272847657041200928206678498436241862369036289177566205634111595034281139043830341990970051405468356521568182096790422711332288985725459606339912971024817175242149551127474721970546692758955168740903802146296136715778711216636515597371470827235909605673030644212146147683420165423567782659608931992550272751648072791033682963533905504481776655868512765289286646491111096179817890463378613715766053844446306000258955296386396096262658263128196482531106092098196027523343836404120911791124421175361706171366572240299015579980284139080882351305231244731584776863423461994237676945919663955172084964985601256253135525105053795381649383184919665533077046117295963904090742608805017164455618579064771591030021563213580040104145964229712529671883977457314415833117030376371539885472812356798363146249127113072407875418156326868507451066343629489786103131009431814396661347323549401289743251225720765024120957907371009438822114577584745705458971480263257039653136148782455696443098591679541072728498247414070349107406500425488214236914307536661449429659234268344149782661287585756766708061294398529894062607870104159149750198038287232440793110291813317087601467238497916202232883774419754661766204719609409705277402588358681225957244617679298842599599610023117753312661094101759025176298334774332683190130205698152873397855982176619128411730985034465124189389846908197400564350238503719905169918724010783567430003896087066266821719553560331903689003010272405593429671114837537458438458810569741328348315203771070449641049670667033626804085095493059660186487699842673204413845960945449014954277070705783609149851724447232290310287950830440580935118718133595616420595565749025042901935889536902611398986818097887543943535375137651588157937639283692944551166829732702164871206021288665268341559991015767647229812099576572894134750988986456522036849951542144773244913421388209088307053496782741176741241513152854781506185380032963347272742318306178932064969357824347769587413146753612751562779630448360854566766404735047639283199529800615581083583286342556383000818670244033041662411186008921963945680447314976461368474883607658173906375791452118237931269789307464520599604387875357788116162028123710672872866041644859592248395894773522870562271043318751097921583503446945964883192134249128965999497320331922270510287675481386667548581932426877418652057563983652037583094515480940476044090797727810509222161070518439055295806601382412704938620448515791971112125902035713432406424295633432447417595587209628936543588418343740182727955969051502675512542782079799667345957640381664969028249839225014257627023244123361328507251786376731625265469681579039235558099613273034615626244670462268171516025298670766046419785758512686120594389760740177509546540842456075409150863218122764579389701550291681546602416139449883059736424809624406306244795133053194979695867805555727738264609178513854457702992959660487368269116331942268653";
        System.out.println(largestOddNumber(s));
    }   
}
/* passed 164/192 test cases time limit exceeded*/
/*
public String largestOddNumber(String s) {
    String maxOdd1 = "", maxOdd2 = "", st = "";
    int j = 0;
    boolean found = false, did = false;

    while (j < s.length()) {
        for (int i = 0; i < s.length()-j; ++i) {
            st = st + s.charAt(i);
        }
        if(isOdd(st) && isGreater(st, maxOdd1)) {
            maxOdd1 = st;
            found = true;
        }
        j++;
        st = "";
    }
    if(!found && maxOdd1.isEmpty()) did = true;
    found = false;

    for (char c : s.toCharArray()) {
        String cstr = String.valueOf(c);
        if(isOdd(cstr) && isGreater(cstr, maxOdd2)) {
            maxOdd2 = cstr;
            found = true;
        }
    }
    if(isGreater(maxOdd2, maxOdd1)) {
        if(!found) return "";
        return maxOdd2;    
    } else {
        if(did) return "";
        return maxOdd1;
    }
}
private boolean isOdd(String str) {
    if(str.isEmpty()) return false;
    int lastDigit = str.charAt(str.length()-1) - '0';
    return lastDigit % 2 != 0;
}
private boolean isGreater(String a, String b) {
    if(a.length() != b.length()) return a.length() > b.length();
    return a.compareTo(b) >= 0;
}
*/
/////////////////////////////////////////////////////////////////////////////
/* passed 105/196 test cases */
/*
public static String largestOddNumber(String s) {
    long maxOdd1 = 1, maxOdd2 = 1;
    int j = 0;
    String st = "";
    boolean found = false, look = false;

    while(j < s.length()) {
        for(int i = 0; i < s.length()-j; ++i) {
            st = st + String.valueOf(s.charAt(i));
        }
        if(Long.parseLong(st) % 2 != 0 && Long.parseLong(st) >= maxOdd1) {
            maxOdd1 = Long.parseLong(st);
            found = true;
        }
        j++;
        st = "";
    }
        
    if(!found && maxOdd1 == 1) look = true;
    found = false;
    System.out.println("maxodd1--->"+maxOdd1);
        
    //if(Integer.parseInt(s) % 2 != 0) return s;

    for(char c : s.toCharArray()) {
        int n = c - '0';
        if(n % 2 != 0 && n >= maxOdd2) {
            maxOdd2 = n;
            System.out.println("n--->"+n);
            System.out.println("maxOdd2--->"+maxOdd2);
            found = true;
        }
    }

    if(maxOdd2 > maxOdd1){
        if(!found) return "";
        return String.valueOf(maxOdd2);    
    } else {
        if(look == true) return "";
        return String.valueOf(maxOdd1);
    }
}
*/
